import credits.aleo;
program oracle_program.aleo;


struct OraclePriceDataEntry:
    null as boolean;
    sig as signature;
    addr as address;
    token_price_id as u64;
    price as u64;
    decimal as u8;
    height as u32;

struct OraclePrice:
    token_price_id as u64;
    price as u64;
    decimal as u8;
    height as u32;

struct PriceEntry:
    price as u64;
    decimal as u8;

struct OracleNode:
    addr as address;
    status as u8;

record OracleNodeStakeNFT:
    owner as address.private;
    balance as u64.private;


mapping price_quote:
	key as u64.public;
	value as PriceEntry.public;


mapping oracle_nodes:
	key as address.public;
	value as OracleNode.public;


mapping total_staked_value:
	key as field.public;
	value as u64.public;

closure data_checker:
    input r0 as OraclePriceDataEntry;
    input r1 as u64;
    input r2 as u8;
    input r3 as u32;
    assert.eq r0.token_price_id r1;
    assert.eq r0.decimal r2;
    assert.eq r0.height r3;


closure update_bitmap_index:
    input r0 as u64;
    input r1 as u8;
    input r2 as boolean;
    shl 1u64 r1 into r3;
    lt r1 8u8 into r4;
    or r0 r3 into r5;
    and r0 r3 into r6;
    ternary r2 r5 r6 into r7;
    ternary r4 r7 r0 into r8;
    output r8 as u64;


closure get_bitmap_index_value:
    input r0 as u64;
    input r1 as u8;
    shl 1u64 r1 into r2;
    and r0 r2 into r3;
    is.neq r3 0u64 into r4;
    output r4 as boolean;


function price_aggregator:
    input r0 as u64.private;
    input r1 as u8.private;
    input r2 as u32.private;
    input r3 as [OraclePriceDataEntry; 8u32].private;
    input r4 as u64.private;
    input r5 as u64.private;
    call data_checker r3[0u32] r0 r1 r2;
    cast r3[0u32].height into r6 as u64;
    add r3[0u32].token_price_id r3[0u32].price into r7;
    add r7 r6 into r8;
    sign.verify r3[0u32].sig r3[0u32].addr r8 into r9;
    sign.verify r3[0u32].sig r3[0u32].addr r8 into r10;
    is.eq r9 r10 into r11;
    is.eq r3[0u32].null false into r12;
    is.eq r12 true into r13;
    pow 10u64 r3[0u32].decimal into r14;
    mul r3[0u32].price r14 into r15;
    add 0u64 r15 into r16;
    call update_bitmap_index 0u64 0u8 true into r17;
    add 0u8 1u8 into r18;
    ternary r13 r16 0u64 into r19;
    ternary r13 r18 0u8 into r20;
    call data_checker r3[1u32] r0 r1 r2;
    cast r3[1u32].height into r21 as u64;
    add r3[1u32].token_price_id r3[1u32].price into r22;
    add r22 r21 into r23;
    sign.verify r3[1u32].sig r3[1u32].addr r23 into r24;
    sign.verify r3[1u32].sig r3[1u32].addr r23 into r25;
    is.eq r24 r25 into r26;
    is.eq r3[1u32].null false into r27;
    is.eq r27 true into r28;
    pow 10u64 r3[1u32].decimal into r29;
    mul r3[1u32].price r29 into r30;
    add r19 r30 into r31;
    call update_bitmap_index 0u64 1u8 true into r32;
    add r20 1u8 into r33;
    ternary r28 r31 r19 into r34;
    ternary r28 r33 r20 into r35;
    call data_checker r3[2u32] r0 r1 r2;
    cast r3[2u32].height into r36 as u64;
    add r3[2u32].token_price_id r3[2u32].price into r37;
    add r37 r36 into r38;
    sign.verify r3[2u32].sig r3[2u32].addr r38 into r39;
    sign.verify r3[2u32].sig r3[2u32].addr r38 into r40;
    is.eq r39 r40 into r41;
    is.eq r3[2u32].null false into r42;
    is.eq r42 true into r43;
    pow 10u64 r3[2u32].decimal into r44;
    mul r3[2u32].price r44 into r45;
    add r34 r45 into r46;
    call update_bitmap_index 0u64 2u8 true into r47;
    add r35 1u8 into r48;
    ternary r43 r46 r34 into r49;
    ternary r43 r48 r35 into r50;
    call data_checker r3[3u32] r0 r1 r2;
    cast r3[3u32].height into r51 as u64;
    add r3[3u32].token_price_id r3[3u32].price into r52;
    add r52 r51 into r53;
    sign.verify r3[3u32].sig r3[3u32].addr r53 into r54;
    sign.verify r3[3u32].sig r3[3u32].addr r53 into r55;
    is.eq r54 r55 into r56;
    is.eq r3[3u32].null false into r57;
    is.eq r57 true into r58;
    pow 10u64 r3[3u32].decimal into r59;
    mul r3[3u32].price r59 into r60;
    add r49 r60 into r61;
    call update_bitmap_index 0u64 3u8 true into r62;
    add r50 1u8 into r63;
    ternary r58 r61 r49 into r64;
    ternary r58 r63 r50 into r65;
    call data_checker r3[4u32] r0 r1 r2;
    cast r3[4u32].height into r66 as u64;
    add r3[4u32].token_price_id r3[4u32].price into r67;
    add r67 r66 into r68;
    sign.verify r3[4u32].sig r3[4u32].addr r68 into r69;
    sign.verify r3[4u32].sig r3[4u32].addr r68 into r70;
    is.eq r69 r70 into r71;
    is.eq r3[4u32].null false into r72;
    is.eq r72 true into r73;
    pow 10u64 r3[4u32].decimal into r74;
    mul r3[4u32].price r74 into r75;
    add r64 r75 into r76;
    call update_bitmap_index 0u64 4u8 true into r77;
    add r65 1u8 into r78;
    ternary r73 r76 r64 into r79;
    ternary r73 r78 r65 into r80;
    call data_checker r3[5u32] r0 r1 r2;
    cast r3[5u32].height into r81 as u64;
    add r3[5u32].token_price_id r3[5u32].price into r82;
    add r82 r81 into r83;
    sign.verify r3[5u32].sig r3[5u32].addr r83 into r84;
    sign.verify r3[5u32].sig r3[5u32].addr r83 into r85;
    is.eq r84 r85 into r86;
    is.eq r3[5u32].null false into r87;
    is.eq r87 true into r88;
    pow 10u64 r3[5u32].decimal into r89;
    mul r3[5u32].price r89 into r90;
    add r79 r90 into r91;
    call update_bitmap_index 0u64 5u8 true into r92;
    add r80 1u8 into r93;
    ternary r88 r91 r79 into r94;
    ternary r88 r93 r80 into r95;
    call data_checker r3[6u32] r0 r1 r2;
    cast r3[6u32].height into r96 as u64;
    add r3[6u32].token_price_id r3[6u32].price into r97;
    add r97 r96 into r98;
    sign.verify r3[6u32].sig r3[6u32].addr r98 into r99;
    sign.verify r3[6u32].sig r3[6u32].addr r98 into r100;
    is.eq r99 r100 into r101;
    is.eq r3[6u32].null false into r102;
    is.eq r102 true into r103;
    pow 10u64 r3[6u32].decimal into r104;
    mul r3[6u32].price r104 into r105;
    add r94 r105 into r106;
    call update_bitmap_index 0u64 6u8 true into r107;
    add r95 1u8 into r108;
    ternary r103 r106 r94 into r109;
    ternary r103 r108 r95 into r110;
    call data_checker r3[7u32] r0 r1 r2;
    cast r3[7u32].height into r111 as u64;
    add r3[7u32].token_price_id r3[7u32].price into r112;
    add r112 r111 into r113;
    sign.verify r3[7u32].sig r3[7u32].addr r113 into r114;
    sign.verify r3[7u32].sig r3[7u32].addr r113 into r115;
    is.eq r114 r115 into r116;
    is.eq r3[7u32].null false into r117;
    is.eq r117 true into r118;
    pow 10u64 r3[7u32].decimal into r119;
    mul r3[7u32].price r119 into r120;
    add r109 r120 into r121;
    call update_bitmap_index 0u64 7u8 true into r122;
    add r110 1u8 into r123;
    ternary r118 r121 r109 into r124;
    ternary r118 r123 r110 into r125;
    gte r125 4u8 into r126;
    assert.eq r126 true;
    cast r125 into r127 as u64;
    div r124 r127 into r128;
    call get_bitmap_index_value 0u64 0u8 into r129;
    gt r3[0u32].price r128 into r130;
    pow 10u64 r3[0u32].decimal into r131;
    mul r3[0u32].price r131 into r132;
    pow 10u64 r1 into r133;
    mul r128 r133 into r134;
    sub r132 r134 into r135;
    pow r135 2u8 into r136;
    add 0u64 r136 into r137;
    pow 10u64 r1 into r138;
    mul r128 r138 into r139;
    pow 10u64 r3[0u32].decimal into r140;
    mul r3[0u32].price r140 into r141;
    sub r139 r141 into r142;
    pow r142 2u8 into r143;
    add 0u64 r143 into r144;
    ternary r130 r137 r144 into r145;
    ternary r129 r145 0u64 into r146;
    call get_bitmap_index_value 0u64 1u8 into r147;
    gt r3[1u32].price r128 into r148;
    pow 10u64 r3[1u32].decimal into r149;
    mul r3[1u32].price r149 into r150;
    pow 10u64 r1 into r151;
    mul r128 r151 into r152;
    sub r150 r152 into r153;
    pow r153 2u8 into r154;
    add r146 r154 into r155;
    pow 10u64 r1 into r156;
    mul r128 r156 into r157;
    pow 10u64 r3[1u32].decimal into r158;
    mul r3[1u32].price r158 into r159;
    sub r157 r159 into r160;
    pow r160 2u8 into r161;
    add r146 r161 into r162;
    ternary r148 r155 r162 into r163;
    ternary r147 r163 r146 into r164;
    call get_bitmap_index_value 0u64 2u8 into r165;
    gt r3[2u32].price r128 into r166;
    pow 10u64 r3[2u32].decimal into r167;
    mul r3[2u32].price r167 into r168;
    pow 10u64 r1 into r169;
    mul r128 r169 into r170;
    sub r168 r170 into r171;
    pow r171 2u8 into r172;
    add r164 r172 into r173;
    pow 10u64 r1 into r174;
    mul r128 r174 into r175;
    pow 10u64 r3[2u32].decimal into r176;
    mul r3[2u32].price r176 into r177;
    sub r175 r177 into r178;
    pow r178 2u8 into r179;
    add r164 r179 into r180;
    ternary r166 r173 r180 into r181;
    ternary r165 r181 r164 into r182;
    call get_bitmap_index_value 0u64 3u8 into r183;
    gt r3[3u32].price r128 into r184;
    pow 10u64 r3[3u32].decimal into r185;
    mul r3[3u32].price r185 into r186;
    pow 10u64 r1 into r187;
    mul r128 r187 into r188;
    sub r186 r188 into r189;
    pow r189 2u8 into r190;
    add r182 r190 into r191;
    pow 10u64 r1 into r192;
    mul r128 r192 into r193;
    pow 10u64 r3[3u32].decimal into r194;
    mul r3[3u32].price r194 into r195;
    sub r193 r195 into r196;
    pow r196 2u8 into r197;
    add r182 r197 into r198;
    ternary r184 r191 r198 into r199;
    ternary r183 r199 r182 into r200;
    call get_bitmap_index_value 0u64 4u8 into r201;
    gt r3[4u32].price r128 into r202;
    pow 10u64 r3[4u32].decimal into r203;
    mul r3[4u32].price r203 into r204;
    pow 10u64 r1 into r205;
    mul r128 r205 into r206;
    sub r204 r206 into r207;
    pow r207 2u8 into r208;
    add r200 r208 into r209;
    pow 10u64 r1 into r210;
    mul r128 r210 into r211;
    pow 10u64 r3[4u32].decimal into r212;
    mul r3[4u32].price r212 into r213;
    sub r211 r213 into r214;
    pow r214 2u8 into r215;
    add r200 r215 into r216;
    ternary r202 r209 r216 into r217;
    ternary r201 r217 r200 into r218;
    call get_bitmap_index_value 0u64 5u8 into r219;
    gt r3[5u32].price r128 into r220;
    pow 10u64 r3[5u32].decimal into r221;
    mul r3[5u32].price r221 into r222;
    pow 10u64 r1 into r223;
    mul r128 r223 into r224;
    sub r222 r224 into r225;
    pow r225 2u8 into r226;
    add r218 r226 into r227;
    pow 10u64 r1 into r228;
    mul r128 r228 into r229;
    pow 10u64 r3[5u32].decimal into r230;
    mul r3[5u32].price r230 into r231;
    sub r229 r231 into r232;
    pow r232 2u8 into r233;
    add r218 r233 into r234;
    ternary r220 r227 r234 into r235;
    ternary r219 r235 r218 into r236;
    call get_bitmap_index_value 0u64 6u8 into r237;
    gt r3[6u32].price r128 into r238;
    pow 10u64 r3[6u32].decimal into r239;
    mul r3[6u32].price r239 into r240;
    pow 10u64 r1 into r241;
    mul r128 r241 into r242;
    sub r240 r242 into r243;
    pow r243 2u8 into r244;
    add r236 r244 into r245;
    pow 10u64 r1 into r246;
    mul r128 r246 into r247;
    pow 10u64 r3[6u32].decimal into r248;
    mul r3[6u32].price r248 into r249;
    sub r247 r249 into r250;
    pow r250 2u8 into r251;
    add r236 r251 into r252;
    ternary r238 r245 r252 into r253;
    ternary r237 r253 r236 into r254;
    call get_bitmap_index_value 0u64 7u8 into r255;
    gt r3[7u32].price r128 into r256;
    pow 10u64 r3[7u32].decimal into r257;
    mul r3[7u32].price r257 into r258;
    pow 10u64 r1 into r259;
    mul r128 r259 into r260;
    sub r258 r260 into r261;
    pow r261 2u8 into r262;
    add r254 r262 into r263;
    pow 10u64 r1 into r264;
    mul r128 r264 into r265;
    pow 10u64 r3[7u32].decimal into r266;
    mul r3[7u32].price r266 into r267;
    sub r265 r267 into r268;
    pow r268 2u8 into r269;
    add r254 r269 into r270;
    ternary r256 r263 r270 into r271;
    ternary r255 r271 r254 into r272;
    cast r125 into r273 as u64;
    sub r273 1u64 into r274;
    div r272 r274 into r275;
    pow 10u64 r1 into r276;
    mul r276 100u64 into r277;
    gt r275 r277 into r278;
    sub r275 r277 into r279;
    lt r279 2u64 into r280;
    and r278 r280 into r281;
    lt r275 r277 into r282;
    sub r277 r275 into r283;
    lt r283 2u64 into r284;
    and r282 r284 into r285;
    ternary r285 true false into r286;
    ternary r281 true r286 into r287;
    not r287 into r288;
    gt r128 r4 into r289;
    sub r128 r4 into r290;
    sub r4 r128 into r291;
    ternary r289 r290 r291 into r292;
    gt r5 r292 into r293;
    assert.eq r293 true;
    cast r3[0u32].addrr3[1u32].addrr3[2u32].addrr3[3u32].addrr3[4u32].addrr3[5u32].addrr3[6u32].addrr3[7u32].addr into r294 as [address; 8u32];
    cast r0 r128 r1 r2 into r295 as OraclePrice;
    async price_aggregator r295 r294 into r296;
    output r296 as oracle_program.aleo/price_aggregator.future;

finalize price_aggregator:
    input r0 as OraclePrice.public;
    input r1 as [address; 8u32].public;
    assert.eq r0.height block.height;
    contains oracle_nodes[r1[0u32]] into r2;
    assert.eq r2 true;
    get oracle_nodes[r1[0u32]] into r3;
    assert.neq r3.status 3u8;
    contains oracle_nodes[r1[1u32]] into r4;
    assert.eq r4 true;
    get oracle_nodes[r1[1u32]] into r5;
    assert.neq r5.status 3u8;
    contains oracle_nodes[r1[2u32]] into r6;
    assert.eq r6 true;
    get oracle_nodes[r1[2u32]] into r7;
    assert.neq r7.status 3u8;
    contains oracle_nodes[r1[3u32]] into r8;
    assert.eq r8 true;
    get oracle_nodes[r1[3u32]] into r9;
    assert.neq r9.status 3u8;
    contains oracle_nodes[r1[4u32]] into r10;
    assert.eq r10 true;
    get oracle_nodes[r1[4u32]] into r11;
    assert.neq r11.status 3u8;
    contains oracle_nodes[r1[5u32]] into r12;
    assert.eq r12 true;
    get oracle_nodes[r1[5u32]] into r13;
    assert.neq r13.status 3u8;
    contains oracle_nodes[r1[6u32]] into r14;
    assert.eq r14 true;
    get oracle_nodes[r1[6u32]] into r15;
    assert.neq r15.status 3u8;
    contains oracle_nodes[r1[7u32]] into r16;
    assert.eq r16 true;
    get oracle_nodes[r1[7u32]] into r17;
    assert.neq r17.status 3u8;
    cast r0.price r0.decimal into r18 as PriceEntry;
    set r18 into price_quote[r0.token_price_id];


function add_node_to_whitelist:
    input r0 as address.private;
    assert.eq self.caller aleo1qgf9yps4vns0mkqxm8vlv607k8k4vdkqjjqttf4e25lwuwnxxsyq7rmczy;
    async add_node_to_whitelist r0 into r1;
    output r1 as oracle_program.aleo/add_node_to_whitelist.future;

finalize add_node_to_whitelist:
    input r0 as address.public;
    cast r0 1u8 into r1 as OracleNode;
    get.or_use oracle_nodes[r0] r1 into r2;
    assert.neq r2.status 3u8;
    set r2 into oracle_nodes[r0];


function ban_node_from_whitelist:
    input r0 as address.private;
    assert.eq self.caller aleo1qgf9yps4vns0mkqxm8vlv607k8k4vdkqjjqttf4e25lwuwnxxsyq7rmczy;
    async ban_node_from_whitelist r0 into r1;
    output r1 as oracle_program.aleo/ban_node_from_whitelist.future;

finalize ban_node_from_whitelist:
    input r0 as address.public;
    cast r0 3u8 into r1 as OracleNode;
    get.or_use oracle_nodes[r0] r1 into r2;
    set r2 into oracle_nodes[r0];
